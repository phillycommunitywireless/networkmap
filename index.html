<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Network Map | Philly Community Wireless</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <!-- mapbox css -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.css" rel="stylesheet">
  <link href='https://api.mapbox.com/mapbox-assembly/v1.5.1/assembly.min.css' rel='stylesheet'>
  <!-- custom css -->
  <link rel="stylesheet" href="style.css">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.js"></script>
  <script src='https://api.mapbox.com/mapbox-assembly/v1.5.1/assembly.js'></script>
</head>

<body>
  <div id="loading">Loading...</div>
  <div id="map">
    <div id="right" class="sidebar flex-center right collapsed">
      <div class="sidebar-content rounded-rect flex-center">
        <div class="bookmarks">
          <div style="font-weight: bold">Select layers:</div>
          <div class='relative bg-gray-lighter mx6 my6 w180 round'>
            <label class='checkbox-container'>
              <input type='checkbox' id="layer1" checked />
              <div class='checkbox mr6 checkbox--s-label'>
                <svg class='icon'>
                  <use xlink:href='#icon-check' />
                </svg>
              </div>
              <img class="layer-icon"
                src="https://raw.githubusercontent.com/phillycommunitywireless/pcwnetworkmap/main/icons/high_sites.png">
              High Sites
            </label>
            <label class='checkbox-container'>
              <input type='checkbox' id="layer4" checked />
              <div class='checkbox mr6 checkbox--s-label'>
                <svg class='icon'>
                  <use xlink:href='#icon-check' />
                </svg>
              </div>
              <img class="layer-icon"
                src="https://raw.githubusercontent.com/phillycommunitywireless/pcwnetworkmap/main/icons/Rooftophubs2.png">
              Main Router
            </label>
            <label class='checkbox-container'>
              <input type='checkbox' id="layer2" checked />
              <div class='checkbox mr6 checkbox--s-label'>
                <svg class='icon'>
                  <use xlink:href='#icon-check' />
                </svg>
              </div>
              <img class="layer-icon"
                src="https://raw.githubusercontent.com/phillycommunitywireless/pcwnetworkmap/main/icons/RooftopHub.png">
              Access Points
            </label>
            <label class='checkbox-container'>
              <input type='checkbox' id="layer3" checked />
              <div class='checkbox mr6 checkbox--s-label'>
                <svg class='icon'>
                  <use xlink:href='#icon-check' />
                </svg>
              </div>
              <img class="layer-icon"
                src="https://raw.githubusercontent.com/phillycommunitywireless/pcwnetworkmap/main/icons/icon1.png"> Mesh
              Nodes
            </label>
            <label class='checkbox-container'>
              <input type='checkbox' id="layer5" />
              <div class='checkbox mr6 checkbox--s-label'>
                <svg class='icon'>
                  <use xlink:href='#icon-check' />
                </svg>
              </div>
              Heatmap
            </label>
          </div>
          <div style="font-weight: bold">Navigate to:</div>
          <div class="inline-flex flex--column">
            <button class="btn btn--gray btn--pill-vt" onclick="navigateToBookmark(1, 67, -120.83)">Norris Sq.
              Park</button>
            <button class="btn btn--gray btn--pill-vc" onclick="navigateToBookmark(2, 64, -168.84)">Fairhill Sq.
              Park</button>
            <button class="btn btn--gray btn--pill-vb" onclick="navigateToBookmark(3, 69, -124.80)">McPherson Sq.
              Park</button>
          </div>
          <div style="font-weight: bold">Animate Network:</div>
          <label class="switch-container">
            <input type="checkbox" id="toggleNetworkLinks" disabled />
            <div class="switch"></div>
            <div>Level 1</div>
          </label>
          <label class="switch-container">
            <input type="checkbox" id="toggleNetworkLinks2" disabled />
            <div class="switch"></div>
            <div>Level 2</div>
          </label>
          <label class="switch-container">
            <input type="checkbox" id="toggleNetworkLinks3" disabled />
            <div class="switch"></div>
            <div>Level 3</div>
          </label>
        </div>
        <div class="sidebar-toggle rounded-rect right" onclick="toggleSidebar('right')">
          &larr;
        </div>

      </div>
    </div>
  </div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.13.0/mapbox-gl.js"></script>
  <script>
    const fetchJSON = (url) => fetch(url).then(r => r.json());

    mapboxgl.accessToken = 'pk.eyJ1IjoiZm12YWxkZXpnODQiLCJhIjoiY2xqajJzZXZ2MDU3ZTNybHBrdHo4OWo4aSJ9.ENnejUYGtJT-74gG0opSQA';

    // Default values for map center and zoom
    // Set distinct map center/zoom via query parameter 
    // eg - /?latitude=39.999330&longitude=-75.109110&zoom=15 
    const DEFAULT_MAP_CENTER = [-75.14034, 39.98718]
    let map_center = []

    const DEFAULT_MAP_ZOOM = 13.39
    let map_zoom = 0

    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    // long/lat
    if (urlParams.has('latitude') & urlParams.has('longitude')){
      map_center = [urlParams.get('longitude'), urlParams.get('latitude') ]
    } else {
      map_center = DEFAULT_MAP_CENTER
    }
    // zoom
    if (urlParams.has('zoom')) {
      map_zoom = urlParams.get('zoom')
    } else {
      map_zoom = DEFAULT_MAP_ZOOM
    }

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/dark-v11',
      zoom: map_zoom,
      center: map_center,
      pitch: 0,
      bearing: 0,
    });

    const images = [
      { imageUrl: 'https://raw.githubusercontent.com/phillycommunitywireless/pcwnetworkmap/main/icons/high_sites.png', id: 'HS_icon' },
      { imageUrl: 'https://raw.githubusercontent.com/phillycommunitywireless/pcwnetworkmap/main/icons/RooftopHub.png', id: 'RH_icon' },
      { imageUrl: 'https://raw.githubusercontent.com/phillycommunitywireless/pcwnetworkmap/main/icons/icon1.png', id: 'MN_icon' },
      { imageUrl: 'https://raw.githubusercontent.com/phillycommunitywireless/pcwnetworkmap/main/icons/Rooftophubs2.png', id: 'LB_icon' },
    ];

    Promise.all(
      images.map(img => new Promise((resolve, reject) => {
        map.loadImage(img.imageUrl, function (error, res) {
          if (error) throw error;
          map.addImage(img.id, res);
          resolve();
        });
      }))
    ).then(() => {
      console.log("Images Loaded");
    });

    // Add the GeoJSON layers to the map
    let layer_one_loaded = false;
    map.on('load', async () => {
      // setup util functions
      const loadNetworkLayer = async (endpoint, name) => {
        const api_endpoint = "https://pcwnetworkmap-internal-api-170f675937bb.herokuapp.com";
        let layer_data;
        try {
          layer_data = await fetchJSON(api_endpoint + endpoint);
          map.addSource(name, {
            type: 'geojson',
            data: layer_data
          });
        }
        catch (e) {
          'error loading network connection layer', name, e
        }
        return layer_data;
      }
      const initAnimateNetworkLine = (id) => {
        // technique based on https://jsfiddle.net/2mws8y3q/
        const dashSequence = [
          [0, 4, 3],
          [0.5, 4, 2.5],
          [1, 4, 2],
          [1.5, 4, 1.5],
          [2, 4, 1],
          [2.5, 4, 0.5],
          [3, 4, 0],
          [0, 0.5, 3, 3.5],
          [0, 1, 3, 3],
          [0, 1.5, 3, 2.5],
          [0, 2, 3, 2],
          [0, 2.5, 3, 1.5],
          [0, 3, 3, 1],
          [0, 3.5, 3, 0.5]
        ];
        let step = 0;
        const animateNetworkLine = (timestamp = 0) => {
          // Update line-dasharray using the next value in dashArraySequence. The
          // divisor in the expression `timestamp / 100` controls the animation speed.
          const nextStep = parseInt((timestamp / 100) % dashSequence.length);
          if (nextStep !== step) {
            map.setPaintProperty(id, 'line-dasharray', dashSequence[step]);
            step = nextStep;
          }
          requestAnimationFrame(animateNetworkLine);
        }
        animateNetworkLine();
      }
      // end util

      // load the basic nodes for display
      const networkpoints_data = await loadNetworkLayer('/get_networkpoints', 'network-points');
      
      if (!networkpoints_data) {
        alert("Error loading network points");
        throw ReferenceError("Didn't load required network points");
      }

      map.addLayer({
        'id': 'network-points-layer',
        'type': 'symbol',
        'source': 'network-points',
        'layout': {
          'icon-image': [
            'match',
            ['get', 'type'],
            'HS', 'HS_icon',
            'RH', 'RH_icon',
            'MN', 'MN_icon',
            'LB', 'LB_icon',
            'default-icon'
          ],
          'icon-size': ['interpolate', ['linear'], ['zoom'], 0, 0.01, 17, 0.45],
          'icon-allow-overlap': false,
          'icon-ignore-placement': true,
        },
        'paint': {
          'icon-opacity': 0.85,
          'text-halo-color': 'rgb(255, 255, 255)',
          'text-halo-width': 2,
          'text-halo-blur': 0.5,
        },
      });

      const loadingMessage = document.querySelector('#loading');
      if (loadingMessage) {
        loadingMessage.style.display = 'none';
      }

      // Level 1
      loadNetworkLayer('/get_level1', 'line').then(() => {
        const animationLineId = 'line-dashed';
        map.addLayer({
          type: 'line',
          source: 'line',
          id: animationLineId,
          visibility: 'none',
          minzoom: 13,
          paint: {
            'line-color': 'lime',
            'line-width': 2,
            'line-opacity': 0.65,
          }
        });
        initAnimateNetworkLine(animationLineId);
        map.setLayoutProperty(animationLineId, 'visibility', 'none');

        const checkbox = document.getElementById("toggleNetworkLinks");
        checkbox.disabled = false;
      })

      // Level 2
      loadNetworkLayer('/get_level2', 'new-line').then(() => {
        const animationLineId = 'new-line-dashed';
        map.addLayer({
          type: 'line',
          source: 'new-line',
          id: animationLineId,
          visibility: 'none',
          minzoom: 13,
          paint: {
            'line-color': 'magenta',
            'line-width': 4,
            'line-opacity': 0.65,
          }
        });
        initAnimateNetworkLine(animationLineId);
        map.setLayoutProperty(animationLineId, 'visibility', 'none');

        const checkbox = document.getElementById("toggleNetworkLinks2");
        checkbox.disabled = false;
      });

      // Level 3
      loadNetworkLayer('/get_level3', 'new-line2').then(() => {
        const animationLineId = 'new-line-dashed2';
        map.addLayer({
          type: 'line',
          source: 'new-line2',
          id: animationLineId,
          visibility: 'none',
          minzoom: 13,
          paint: {
            'line-color': 'yellow',
            'line-width': 4,
            'line-opacity': 0.65,
          }
        });
        initAnimateNetworkLine(animationLineId);
        map.setLayoutProperty('new-line-dashed2', 'visibility', 'none');
        
        const checkbox = document.getElementById("toggleNetworkLinks3");
        checkbox.disabled = false;
      });

      // Create heatmap based on features' "type" property
      const filteredData = networkpoints_data.features.filter(feature => feature.properties.type === 'RH' || feature.properties.type === 'MN' || feature.properties.type === 'LB');
      map.addSource('heatmap-source', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: filteredData
        }
      });

      const heatmapLayer = {
        id: 'heatmap-layer',
        type: 'heatmap',
        source: 'heatmap-source',
        minzoom: 12,
        maxzoom: 20,
        paint: {
          'heatmap-weight': 5,
          'heatmap-intensity': 1,
          'heatmap-color': [
            'interpolate',
            ['linear'],
            ['heatmap-density'],
            0, 'rgba(0, 0, 255, 0)',
            0.2, 'rgba(255, 0, 0, 1)',
            0.4, 'rgba(255, 165, 0, 1)',
            0.6, 'rgba(255, 255, 0, 1)',
            0.8, 'rgba(0, 255, 0, 1)'
          ],
          'heatmap-radius': {
            stops: [
              [9, 2],
              [11, 10],
              [13, 20],
              [15, 100],
              [17, 200],
              [19, 500],
              [23, 1000]
            ]
          },
          'heatmap-opacity': {
            default: 1,
            stops: [
              [14, 0.5],
              [20, 0.2]
            ]
          }
        },
        visibility: 'none'
      };

      map.addLayer(heatmapLayer);
      map.setLayoutProperty(heatmapLayer.id, 'visibility', 'none');

      map.on('mouseenter', 'network-points-layer', (e) => {
        map.getCanvas().style.cursor = 'pointer';
        const coordinates = e.features[0].geometry.coordinates.slice();
        const nameProperty = e.features[0].properties.name; // Make sure this property exists in your data
        const imageLink = e.features[0].properties.image; // Make sure this property exists in your data
        const popupContent = `
            <div class="popup-image-container">
                <h3>${nameProperty}</h3>
                <!--<img src="${imageLink}" alt="Image" class="popup-image"> uncomment once images exist in img folder-->
            </div>`;
        popup.setLngLat(coordinates).setHTML(popupContent).addTo(map);
      });

      map.on('mouseleave', 'network-points-layer', () => {
        map.getCanvas().style.cursor = '';
        popup.remove();
      });

    });
    //end map.on('load')

    const toggleCheckbox = document.getElementById('toggleNetworkLinks');
    toggleCheckbox.addEventListener('change', () => {
      map.setLayoutProperty(
        'line-dashed',
        'visibility',
        toggleCheckbox.checked ? 'visible' : 'none'
      );
    });

    const newLayerCheckbox = document.getElementById('toggleNetworkLinks2');
    newLayerCheckbox.addEventListener('change', () => {
      map.setLayoutProperty(
        'new-line-dashed',
        'visibility',
        newLayerCheckbox.checked ? 'visible' : 'none'
      );
    });

    const newLayerCheckbox2 = document.getElementById('toggleNetworkLinks3');
    newLayerCheckbox2.addEventListener('change', () => {
      map.setLayoutProperty(
        'new-line-dashed2',
        'visibility',
        newLayerCheckbox2.checked ? 'visible' : 'none'
      );
    });

    const popup = new mapboxgl.Popup({ closeButton: false, closeOnClick: false });

    function navigateToBookmark(bookmarkId, pitch, bearing) {
      switch (bookmarkId) {
        case 1:
          map.flyTo({
            center: [-75.13430, 39.98393],
            zoom: 16.50,
            pitch: pitch,
            bearing: bearing,
            speed: 0.8,
            curve: 1.2,
          });
          break;
        case 2:
          map.flyTo({
            center: [-75.14355, 39.99292],
            zoom: 15.20,
            pitch: pitch,
            bearing: bearing,
            speed: 0.8,
            curve: 1.2,
          });
          break;
        case 3:
          map.flyTo({
            center: [-75.11241, 39.99722],
            zoom: 15.94,
            pitch: pitch,
            bearing: bearing,
            speed: 0.8,
            curve: 1.2,
          });
          break;
        default:
          break;
      }

    }


    map.on('style.load', () => {
      // Insert the layer beneath any symbol layer.
      const layers = map.getStyle().layers;
      const labelLayerId = layers.find(
        (layer) => layer.type === 'symbol' && layer.layout['text-field']
      ).id;

      // The 'building' layer in the Mapbox Streets
      // vector tileset contains building height data
      // from OpenStreetMap.
      map.addLayer(
        {
          'id': 'add-3d-buildings',
          'source': 'composite',
          'source-layer': 'building',
          'filter': ['==', 'extrude', 'true'],
          'type': 'fill-extrusion',
          'minzoom': 15,
          'visibility': 'none',
          'paint': {
            'fill-extrusion-color': '#aaa',

            // Use an 'interpolate' expression to
            // add a smooth transition effect to
            // the buildings as the user zooms in.
            'fill-extrusion-height': [
              'interpolate',
              ['linear'],
              ['zoom'],
              15,
              0,
              15.05,
              ['get', 'height']
            ],
            'fill-extrusion-base': [
              'interpolate',
              ['linear'],
              ['zoom'],
              15,
              0,
              15.05,
              ['get', 'min_height']
            ],
            'fill-extrusion-opacity': 0.6
          }
        },
        labelLayerId
      );
    });




    // Create an object to track the visibility status of each layer
    const visibilityStatus = {
      HS: true,
      RH: true,
      MN: true,
      LB: true
    };

    // Create an object to store the filter expressions for each layer
    const layerFilters = {
      HS: ['==', ['get', 'type'], 'HS'],
      RH: ['==', ['get', 'type'], 'RH'],
      MN: ['==', ['get', 'type'], 'MN'],
      LB: ['==', ['get', 'type'], 'LB']
    };

    // Function to update the visibility of points based on filters
    function updatePointsVisibility() {
      const filters = ['any'];

      for (const type in layerFilters) {
        if (visibilityStatus[type]) {
          filters.push(layerFilters[type]);
        }
      }

      map.setFilter('network-points-layer', filters);
    }


    // Function to update the visibility of points based on filters
    function updatePointsVisibility() {
      const filters = ['any'];

      for (const type in layerFilters) {
        if (visibilityStatus[type]) {
          filters.push(layerFilters[type]);
        }
      }

      map.setFilter('network-points-layer', filters);
    }

    // Add event listeners to the checkbox inputs for each layer
    const layer1Checkbox = document.getElementById('layer1');
    layer1Checkbox.addEventListener('change', () => {
      visibilityStatus.HS = layer1Checkbox.checked;
      updatePointsVisibility();
    });

    const layer2Checkbox = document.getElementById('layer2');
    layer2Checkbox.addEventListener('change', () => {
      visibilityStatus.RH = layer2Checkbox.checked;
      updatePointsVisibility();
    });

    const layer3Checkbox = document.getElementById('layer3');
    layer3Checkbox.addEventListener('change', () => {
      visibilityStatus.MN = layer3Checkbox.checked;
      updatePointsVisibility();
    });

    const layer4Checkbox = document.getElementById('layer4');
    layer4Checkbox.addEventListener('change', () => {
      visibilityStatus.LB = layer4Checkbox.checked;
      updatePointsVisibility();
    });

    // Add event listener to the checkbox input for heatmap layer
    const layer5Checkbox = document.getElementById('layer5');
    layer5Checkbox.addEventListener('change', () => {
      toggleHeatmapLayer();
    });

    function toggleHeatmapLayer() {
      if (layer5Checkbox.checked) {
        map.setLayoutProperty('heatmap-layer', 'visibility', 'visible');
      } else {
        map.setLayoutProperty('heatmap-layer', 'visibility', 'none');
      }
    }

    const nav = new mapboxgl.NavigationControl({
      visualizePitch: true
    });
    map.addControl(nav, 'bottom-right');

    function toggleSidebar(id) {
      const elem = document.getElementById(id);
      // Add or remove the 'collapsed' CSS class from the sidebar element.
      // Returns boolean "true" or "false" whether 'collapsed' is in the class list.
      const collapsed = elem.classList.toggle('collapsed');
      const padding = {};
      // 'id' is 'right' or 'left'. When run at start, this object looks like: '{left: 300}';
      padding[id] = collapsed ? 0 : 300; // 0 if collapsed, 300 px if not. This matches the width of the sidebars in the .sidebar CSS class.
      // Use `map.easeTo()` with a padding option to adjust the map's center accounting for the position of sidebars.
      map.easeTo({
        padding: padding,
        duration: 1000 // In ms. This matches the CSS transition duration property.
      });
    }

    map.on('load', () => {
      toggleSidebar('right');
    });
  </script>
</body>

</html>
